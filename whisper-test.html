<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whisper Transcription Test</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .test-card {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      margin-bottom: 20px;
    }

    .status-badge {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .status-badge.success {
      background: #d4edda;
      color: #155724;
    }

    .status-badge.error {
      background: #f8d7da;
      color: #721c24;
    }

    .status-badge.pending {
      background: #fff3cd;
      color: #856404;
    }

    .platform-info {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .platform-info h3 {
      margin-bottom: 10px;
      color: #333;
    }

    .platform-info p {
      color: #666;
      line-height: 1.6;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin: 20px 0;
    }

    button {
      flex: 1;
      padding: 15px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-start {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-start:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-stop {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .btn-stop:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
    }

    .btn-clear {
      background: #6c757d;
      color: white;
      flex: 0.3;
    }

    .transcript-display {
      margin-top: 20px;
    }

    .transcript-display h4 {
      margin-bottom: 10px;
      color: #333;
    }

    .transcript-box {
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      color: #333;
    }

    .transcript-box.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #adb5bd;
      font-style: italic;
    }

    .info-section {
      margin-top: 20px;
      padding: 20px;
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      border-radius: 4px;
    }

    .info-section h4 {
      color: #1976D2;
      margin-bottom: 10px;
    }

    .info-section ul {
      margin-left: 20px;
      color: #555;
      line-height: 1.8;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }

    .status-indicator.active {
      background: #28a745;
    }

    .status-indicator.inactive {
      background: #dc3545;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéôÔ∏è Whisper Transcription Test</h1>
      <p>Test the cross-platform transcription service</p>
    </div>

    <div class="test-card">
      <div id="connectionStatus"></div>

      <div class="platform-info">
        <h3 id="platformTitle">Detecting platform...</h3>
        <p id="platformMessage">Please wait...</p>
      </div>

      <div class="controls">
        <button class="btn-start" id="startBtn" onclick="startRecording()">
          ‚ñ∂Ô∏è Start Recording
        </button>
        <button class="btn-stop" id="stopBtn" onclick="stopRecording()" disabled>
          ‚èπÔ∏è Stop
        </button>
        <button class="btn-clear" id="clearBtn" onclick="clearTranscript()">
          üóëÔ∏è
        </button>
      </div>

      <div class="transcript-display">
        <h4>
          <span class="status-indicator" id="statusDot"></span>
          Live Transcript:
          <small id="charCount" style="color: #6c757d; font-weight: normal;"></small>
        </h4>
        <div class="transcript-box empty" id="transcriptBox">
          Transcript will appear here...
        </div>
      </div>

      <div class="info-section">
        <h4>üí° Instructions</h4>
        <ul id="instructions">
          <li>Loading...</li>
        </ul>
      </div>
    </div>
  </div>

  <script type="module">
    // Simple device detection
    const DeviceDetector = {
      isDesktop() {
        return !this.isMobile();
      },
      isMobile() {
        return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      },
      isiOS() {
        return /iPhone|iPad|iPod/i.test(navigator.userAgent);
      },
      supportsSystemAudio() {
        const isChrome = /Chrome|Chromium|Edge/i.test(navigator.userAgent);
        return this.isDesktop() && isChrome;
      },
      getPlatformName() {
        if (this.isiOS()) return 'iOS';
        if (/Android/.test(navigator.userAgent)) return 'Android';
        if (/Windows/.test(navigator.userAgent)) return 'Windows';
        if (/Mac/.test(navigator.userAgent)) return 'macOS';
        return 'Desktop';
      },
      getBrowserName() {
        if (/Chrome/i.test(navigator.userAgent) && !/Edge/i.test(navigator.userAgent)) return 'Chrome';
        if (/Edge/i.test(navigator.userAgent)) return 'Edge';
        if (/Firefox/i.test(navigator.userAgent)) return 'Firefox';
        if (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent)) return 'Safari';
        return 'Unknown';
      }
    };

    // Simple WebSocket client
    let ws = null;
    let mediaRecorder = null;
    let stream = null;
    let isRecording = false;
    let transcript = '';
    let audioChunks = [];  // Accumulate all audio chunks

    // Backend URL
    const BACKEND_URL = 'ws://localhost:3001';

    // Update UI based on platform
    function updatePlatformInfo() {
      const platform = DeviceDetector.getPlatformName();
      const browser = DeviceDetector.getBrowserName();
      const supportsSystemAudio = DeviceDetector.supportsSystemAudio();

      document.getElementById('platformTitle').textContent = `${platform} - ${browser}`;

      if (supportsSystemAudio) {
        document.getElementById('platformMessage').textContent = 'üñ•Ô∏è Perfect for Zoom meetings - System audio can be captured';
        document.getElementById('instructions').innerHTML = `
          <li>Click "Start Recording"</li>
          <li>Select your Zoom window or entire screen</li>
          <li><strong style="color: #dc3545;">‚úÖ CHECK "Share audio" checkbox</strong></li>
          <li>Click "Share" to begin</li>
          <li>Transcription will appear in real-time</li>
        `;
      } else {
        document.getElementById('platformMessage').textContent = 'üì± Perfect for in-person meetings - Microphone will be captured';
        document.getElementById('instructions').innerHTML = `
          <li>Click "Start Recording"</li>
          <li>Allow microphone access when prompted</li>
          <li>Place device near speakers</li>
          <li>Speak clearly into the microphone</li>
          <li>Transcription will appear in real-time</li>
        `;
      }
    }

    // Connect to backend
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        ws = new WebSocket(BACKEND_URL);

        ws.onopen = () => {
          console.log('‚úÖ Connected to backend');
          updateConnectionStatus(true);
          resolve();
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);

          if (data.type === 'transcript') {
            transcript += '\n' + data.text;
            updateTranscript();
          } else if (data.type === 'ready') {
            console.log('‚úÖ Backend ready');
          } else if (data.type === 'error') {
            console.error('‚ùå Backend error:', data.message);
            alert('Error: ' + data.message);
          }
        };

        ws.onerror = (error) => {
          console.error('‚ùå WebSocket error:', error);
          updateConnectionStatus(false);
          reject(error);
        };

        ws.onclose = () => {
          console.log('üîå Disconnected from backend');
          updateConnectionStatus(false);
        };
      });
    }

    // Start recording
    window.startRecording = async function() {
      try {
        document.getElementById('startBtn').disabled = true;
        document.getElementById('statusDot').className = 'status-indicator active';

        // Connect to backend
        await connectWebSocket();

        // Capture audio
        const supportsSystemAudio = DeviceDetector.supportsSystemAudio();

        // Always use microphone for now (system audio requires video track)
        stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        console.log('‚úÖ Got microphone stream');

        // Find best supported MIME type
        let mimeType = '';
        const possibleTypes = [
          'audio/webm;codecs=opus',
          'audio/webm',
          'audio/ogg;codecs=opus',
          'audio/mp4',
          ''
        ];

        for (const type of possibleTypes) {
          if (!type || MediaRecorder.isTypeSupported(type)) {
            mimeType = type;
            console.log('‚úÖ Using MIME type:', mimeType || 'default');
            break;
          }
        }

        mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});

        // Accumulate chunks instead of sending immediately
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
            console.log(`Recorded chunk ${audioChunks.length}, size: ${event.data.size} bytes`);
          }
        };

        // When recording stops, send complete audio
        mediaRecorder.onstop = () => {
          console.log(`Recording stopped. Total chunks: ${audioChunks.length}`);
          if (audioChunks.length > 0 && ws && ws.readyState === WebSocket.OPEN) {
            // Combine all chunks into a single Blob
            const completeBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
            console.log(`Sending complete audio: ${completeBlob.size} bytes`);

            const reader = new FileReader();
            reader.onloadend = () => {
              if (ws && ws.readyState === WebSocket.OPEN) {
                const base64Audio = reader.result.split(',')[1];
                ws.send(JSON.stringify({
                  type: 'audio',
                  data: base64Audio
                }));
                console.log('‚úÖ Complete audio sent to backend');

                // Close WebSocket after sending audio and waiting for response
                setTimeout(() => {
                  if (ws) {
                    ws.close();
                    ws = null;
                  }
                }, 30000);  // Wait 30 seconds for transcription
              }
            };
            reader.readAsDataURL(completeBlob);
          } else {
            // No audio to send, close immediately
            if (ws) {
              ws.close();
              ws = null;
            }
          }
          audioChunks = [];  // Clear chunks
        };

        mediaRecorder.start(250); // Record in 250ms chunks (just for internal buffering)
        isRecording = true;

        document.getElementById('stopBtn').disabled = false;
        console.log('üéôÔ∏è Recording started');

      } catch (error) {
        console.error('‚ùå Failed to start recording:', error);
        alert('Failed to start recording: ' + error.message);
        document.getElementById('startBtn').disabled = false;
        document.getElementById('statusDot').className = 'status-indicator inactive';
      }
    };

    // Stop recording
    window.stopRecording = function() {
      if (mediaRecorder && isRecording) {
        mediaRecorder.stop();  // This will trigger onstop event which sends audio
        isRecording = false;
      }

      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }

      // Don't close WebSocket here - let onstop handler do it after sending audio

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('statusDot').className = 'status-indicator inactive';

      console.log('‚èπÔ∏è Recording stopped');
    };

    // Clear transcript
    window.clearTranscript = function() {
      transcript = '';
      updateTranscript();
    };

    // Update transcript display
    function updateTranscript() {
      const box = document.getElementById('transcriptBox');
      if (transcript.trim()) {
        box.textContent = transcript.trim();
        box.classList.remove('empty');
        document.getElementById('charCount').textContent = `(${transcript.length} characters)`;
      } else {
        box.textContent = 'Transcript will appear here...';
        box.classList.add('empty');
        document.getElementById('charCount').textContent = '';
      }

      // Auto-scroll to bottom
      box.scrollTop = box.scrollHeight;
    }

    // Update connection status
    function updateConnectionStatus(connected) {
      const statusDiv = document.getElementById('connectionStatus');
      if (connected) {
        statusDiv.innerHTML = '<div class="status-badge success">‚úÖ Connected to Backend</div>';
      } else {
        statusDiv.innerHTML = '<div class="status-badge error">‚ùå Backend Disconnected</div>';
      }
    }

    // Initialize
    updatePlatformInfo();
    updateConnectionStatus(false);
    document.getElementById('statusDot').className = 'status-indicator inactive';

    // Test backend connection on load
    fetch('http://localhost:3001/health')
      .then(res => res.json())
      .then(data => {
        console.log('‚úÖ Backend health check:', data);
        document.getElementById('connectionStatus').innerHTML =
          '<div class="status-badge pending">‚ö†Ô∏è Ready to connect (click Start Recording)</div>';
      })
      .catch(err => {
        console.error('‚ùå Backend not available:', err);
        document.getElementById('connectionStatus').innerHTML =
          '<div class="status-badge error">‚ùå Backend not running (start with: cd backend && npm start)</div>';
      });
  </script>
</body>
</html>
